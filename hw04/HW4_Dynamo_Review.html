<p><b>1. Summary</b></p><p>Amazon's e-commerce business had grown to a massive level by the mid-2000s, and one of the main problems it faced as it continued to grow was how to scale up its data processing and storage reliably. With several critical e-commerce transactions occurring each second, even a minute's failure of a server could lead to large financial losses. Amazon developed Dynamo, a highly available key-value data store, in order to provide a way to store data reliably, so as to give it an appearance of being always on.</p><p>Dynamo was a NoSQL database, and it was formed as a combination of various algorithms. It proved to be the first successful NoSQL database working on a large scale and acted as a precursor to several other NoSQL databases. Dynamo was used internally by Amazon, and later AWS developed DynamoDB which was available to use by customers as a service provided by AWS.</p><p>Some of the considerations made by Amazon while building Dynamo were -&nbsp;</p><p></p><ol><li>They observed that a majority of the operations being run by the engineers were of the key-value type, where only a single value was returned against a corresponding unique ID value. As relational operations such as JOIN are computationally expensive, the engineers decided to model Dynamo as a NoSQL database.</li><li>Amazon chose to prioritize availability and fault tolerance over consistency for Dynamo. They observed that the system not being able to return results would cause a large amount of loss, however, a system that is not immediately consistent (but eventually becomes consistent) would not impact the sales that much.</li><li>The team predicted more growth for Amazon, and hence also focused on making the system infinitely scalable. As they weren't stringent on immediate consistency, it allowed Dynamo to easily make replicas of the data, which allowed it to scale more easily without affecting its performance.</li></ol><span style="font-family:'-apple-system', BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';">The Dynamo architecture consisted of multiple techniques and algorithms which worked together to meet these requirements as a scalable database solution. Broadly speaking, the techniques used were -&nbsp;</span><p></p><ol><li><span style="font-family:'-apple-system', BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';">Consistent hashing for partitioning the data.</span></li><li><span style="font-family:'-apple-system', BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';">Vector clocks with reconciliation during reads to enable high availability during writes</span></li><li><span style="font-family:'-apple-system', BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';">Sloppy Quorum and hinted handoff for handling temporary failures.</span></li><li><span style="font-family:'-apple-system', BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';">Merkle trees to recover from permanent failures.</span></li><li><span style="font-family:'-apple-system', BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';">Gossip-based membership protocol and failure detection.</span></li></ol><p><br></p><p><b>2. Strengths</b></p><p>The following are the main advantages of using Dynamo -&nbsp;</p><p></p><ol><li>By using consistent hashing for partitioning data, it becomes much easier to scale out the system. The addition of a new node would not lead to a redistribution of data over all partitions.</li><li>By implementing quorums, the data read or write can be validated as correct as it ensures that it is replicated over the required number of servers. This ensures high availability and durability even if some servers are unavailable.</li><li>Vector clocks allow version numbers to be decoupled from update rates, this means that multiple updates can be written to the database simultaneously without having to worry about version number conflicts.</li><li>Dynamo has a very simple interface, making it largely user friendly. Its main two functions are the <i>get()</i> and <i>put()</i> functions.<br></li></ol><p><br></p><p><b>3.&nbsp;Unclear Aspects</b></p><p>The following aspects remain unclear with respect to Dynamo -&nbsp;</p><p></p><ol><li><span style="font-family:'-apple-system', BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';">The paper does not describe in detail how the various techniques are able to interact with each other.</span></li><li><span style="font-family:'-apple-system', BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';">The paper does not go into detail about how each individual technique works, how they were integrated into the system, and what were their advantages compared to any other alternatives.</span></li><li><span style="font-family:'-apple-system', BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';">Unclear about the amount of overhead taken by all these techniques.</span></li></ol><p><br></p><p><b>4.&nbsp;Limitations</b></p><p>The following are the limitations and areas of improvement for Dynamo -&nbsp;<br></p><p></p><ol><li>No provision for automatic recovery from server failure like in GFS.</li><li>Trades off on consistency by design and hence would not be suitable for time-critical transactional applications.</li><li>Dynamo should maintain its performance even at very high scales. With an increase in scale cost of overheads may increase leading to a drop off in performance.</li><li>Dynamo also needs to be manageable at scale. The need for manual capacity planning and provisioning should not act as a deterrent, and it should be able to self provision and auto-scale.</li></ol>